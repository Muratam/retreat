// 並列コンパイル・高速(差分)コンパイルしたい。静的型付けでコンパイルできて高速実行したい
// ボドゲ作ったり遊んだりできる？Gpuの実験もできる？言葉の解釈もできる？

## Grammar
コンピュータでも変更しやすくて、制御フローがわかりやすくて一貫性のある言語
```rust
// 0. コア部分はRustで書く
// 1. 欲望&解釈器(つまり初期値)&API を我々がYuni言語でプログラムする
// 2. 実行すると「自己が実行するコードを生成、解釈器・APIも適宜更新(git commit も)」。チューニングされていく。
// 3. 大量のデータと、ただの評価関数の二乗誤差でやる場合は Deep Learning が必要。

// // まずはプログラミングの才能を伸ばしたい
// 例) 特定のA問題解く器
// - API: 標準入出力(不変)
// - 欲望: 問題概要Tokenとサンプル列とテストケース列を受け取って
//        テストケース列への答えを正答するコードを生成したい(不変)
// - 解釈器の更新器：プログラミングのコツを与える(不変)
// - 解釈器: 更新器に従ってよしなに自己を変えていく(生成コードがよくなっていくはず)
// 例2) 一般的なA問題解く器
// - 例1の一般化が進むに従ってメタ度が上がっていき、やがて一般的なA問題解く器ができるはず
// 例3) A問題の問題文を与えると解く器
// - 言語パース欲望を強くしていくとできそう。

// 最終的なコードには存在しないが、解釈器には存在する型と構文
// コード(AST)を受け取ってコード(AST)を出力する所なので、変な状態になっても問題なし。
// 依存関係や参照関係を見て...
Code ::= Stmt Code
Stmt ::= "{" Stmt "}" | Expr ";" Stmt | Expr
Expr ::= "" | Token | """ Unicodes """
         "if" Stmt "{" Stmt "}" "else" "{" Stmt "}" |
         "if" Stmt "{" Stmt "}" |
         "for" Bind "{" Stmt "}" | "loop" "{" Stmt "}" |
         "break" Stmt "{" Stmt "}" | "import" Stmt |
         Bind | Token "=" Stmt |
         "module" "{" ___ "}" |
         "struct" "{" ___ "}" | Stmt "impl" |
         "(..., ...) Type? {}" |
         Expr "(" ")" |
Bind ::= Token ":=" Stmt
Unicodes ::= /.*/
Token ::= /[_a-zA-Z0-9]+/ | "`" /.*/ "`"
```
